<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://smartchaos.github.io/</id>
    <title>沉舟录</title>
    <updated>2020-01-08T10:59:33.092Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://smartchaos.github.io/"/>
    <link rel="self" href="https://smartchaos.github.io/atom.xml"/>
    <subtitle>沉舟侧畔千帆过，病树前头万木春</subtitle>
    <logo>https://smartchaos.github.io/images/avatar.png</logo>
    <icon>https://smartchaos.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 沉舟录</rights>
    <entry>
        <title type="html"><![CDATA[[Read Digest] 2020-01-08]]></title>
        <id>https://smartchaos.github.io/rOIE_LP-e</id>
        <link href="https://smartchaos.github.io/rOIE_LP-e">
        </link>
        <updated>2020-01-08T08:25:34.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li><a href="https://mp.weixin.qq.com/s/2Cs8ybu5Kg9QYr5Jgyu6VA"><strong>毕业10年才懂，会升层思考，工作有多轻松</strong></a>
<ul>
<li>问题的本质是事物的矛盾，准确定义问题是成功的开始。</li>
<li>准确定义问题需要从定性和定量两个角度进行，核心关注的是主要/次要、紧急/不紧急，其中重要性往往用预期和现实的落差衡量，需要通过度量的方式明晰。</li>
<li>问题一般可以划分为三类：恢复原状型、防范风险型、追求理想型，不同类别的问题需要采用不同的手段处理。</li>
<li>问题定义里常见问题是<strong>把方法和手段当问题</strong>、<strong>误把挑战当问题</strong>、<strong>思考问题缺少时间维度</strong></li>
<li>升层思考:  我们不能只局限于问题本身，还需要看到问题背后的问题，然后才能更容易的找到更多的解决方案。缺乏升层思考的升维思考是不完整的自顶向下。</li>
<li>升层思考问题，升维思考手段/方法。</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一文读懂Java的Classloader机制]]></title>
        <id>https://smartchaos.github.io/yi-wen-du-dong-java-de-classloader-ji-zhi</id>
        <link href="https://smartchaos.github.io/yi-wen-du-dong-java-de-classloader-ji-zhi">
        </link>
        <updated>2019-07-25T02:53:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="java-classloader是怎样定义的">Java Classloader是怎样定义的</h2>
<p>从wikipedia上我们可以找到Java Classloader的定义：</p>
<blockquote>
<p>The Java Class Loader is a part of the Java Runtime Environment that dynamically loads Java classes into the Java Virtual Machine.</p>
</blockquote>
<p>这个定义从用途角度出发明确了Java Classloader的核心职责：将Java class动态加载到JVM中。<br>
从概念上看，classloader和JVM以及JRE的关系如下图<br>
<img src="https://smartchaos.github.io//post-images/1564105434232.png" alt="classloader和JVM的关系" loading="lazy"><br>
从功能视角来看，classloader提供了一种能力，把操作系统里的文件和文件格式差异抹平，以统一的class格式提供给JVM。如下图：<br>
<img src="https://smartchaos.github.io//post-images/1564106049903.png" alt="classloader的功能视角" loading="lazy"></p>
<h2 id="classloader的分类">classloader的分类</h2>
<p>JDK为我们提供了多种classloader, 从上到下依次是：</p>
<ol>
<li>Bootstrap Classloader, 这个是根加载器，加载java_home/lib下的类库，JDK专用，开发者无法直接获取和使用。</li>
<li>Extension Classloader是扩展类加载器，负责加载java_home/lib/ext路径下的类和系统变量java.ext.dir定义路径下的类。这个有了一定的自由度，并且支持开发者直接访问和使用。</li>
<li>App Classloader是应用类加载器（又称系统类加载器），负责加载classpath下的类库，开发者可以直接使用。<br>
除此之外还可以自定义自己的类加载器 。这些类加载器的层级结构如下图：<br>
<img src="https://smartchaos.github.io//post-images/1578385308928.png" alt="classloader的层级关系" loading="lazy"></li>
</ol>
<h2 id="classloader的工作过程">classloader的工作过程</h2>
<p>classloader的工作过程大致是这样的：</p>
<ol>
<li>找到要加载的类 findClass</li>
<li>对要加载的类进行增删改</li>
<li>加载类 loadClass<br>
我们在实现自己的classloader的过程中一般也就是根据需要实现相关的操作。</li>
</ol>
<h2 id="双亲委派机制">双亲委派机制</h2>
<p>多个classloader在加载类的过程中，难免会遇到冲突问题：同样路径和名字的类，到底由谁来加载呢？</p>
<p>JDK提供的解决方案是“双亲委派”，以确定classloader的优先级。<br>
具体策略是在子classloader中发现某个类并不着急加载它，而是委托给它的parent，parent classloader也不着急加载，也是优先去自己的parent classloader询问。如此递归一直找到Bootstrap Classloader, 如果路径中都找不到，那么最末端的子classloader加载，否则就是最上游的类加载器加载。</p>
<p>这个模型的设定是：你写的不如官方的靠谱，核心功能不要随便改写，否则后果不可预料。初衷无疑是为了安全和可靠。</p>
<h2 id="现实世界的classloader">现实世界的classloader</h2>
<p>现实世界中有很多类型的classloader，下面介绍两个在项目开发中常见的两个：</p>
<h3 id="spring和sring-mvc的classloader">Spring和Sring mvc的classloader</h3>
<h3 id="spring-boot-devtools的classcloader">Spring boot devtools的classcloader</h3>
<h2 id="什么时候你需要定义自己的classloader">什么时候你需要定义自己的classloader</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[中关村软件园孵化器楼停车攻略]]></title>
        <id>https://smartchaos.github.io/zhong-guan-cun-ruan-jian-yuan-yi-qi-xi-nan-ting-che-gong-lue</id>
        <link href="https://smartchaos.github.io/zhong-guan-cun-ruan-jian-yuan-yi-qi-xi-nan-ting-che-gong-lue">
        </link>
        <updated>2019-05-21T00:30:15.000Z</updated>
        <content type="html"><![CDATA[<p>近期搬到新办公地点，是除了公共配套之外都很不错的办公区域。公共配套中尤为突出的是交通问题，作为开车一族（就我而言不开车更难受，几公里的距离需要倒3辆车+步行1km），用两天时间把周边转了个遍，整理出一个简单的停车攻略。</p>
<h2 id="软件园内">软件园内</h2>
<p>这里的特点是每栋大厦自成体系，宁可空着车位也要守住自己的“一亩三分地”。所以内部基本上没有对外开放的停车场，唯一的清流是“数字山谷大厦”，</p>
<blockquote>
<p>停车费标准：无包月，大概200+车位。<br>
地面停车：7-19点1元/15分钟, 不封顶；19-次日7点3元/h, 不封顶。<br>
地库停车：7-19点1.5元/15分钟, 不封顶；19-次日7点4元/h，不封顶。</p>
</blockquote>
<p>除了这个选择之外，还可以停在东南侧环宇大厦往东的路边（算园区路边停车位），收费0.5元/15分钟，院区内公共停车位实际数量比较少，难以找到。</p>
<h2 id="周边停车场">周边停车场</h2>
<ol>
<li>南面百旺绿茵停车场，价格4元每小时, 可以包月400，季付1000，车位比较充足，距离孵化器1.2km+。</li>
<li>东大停车场（西），包月300，车位总体充足，步行到孵化器900米。从这个停车场出去后的后厂村路左转车道常年拥堵，一般需要2-3个红绿灯才能通过。</li>
<li>西南侧软通动力南停车场，车入口接近浪潮大厦，东北角有个人行入口，200每月， 车位充足。需要注意的是这个停车场地面是土质的，下雨可能和泥。</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://smartchaos.github.io//post-images/1560395965166.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[唯物唯心]]></title>
        <id>https://smartchaos.github.io/wei-wu-wei-xin</id>
        <link href="https://smartchaos.github.io/wei-wu-wei-xin">
        </link>
        <updated>2019-04-23T07:17:20.000Z</updated>
        <content type="html"><![CDATA[<p>高中时一位历史老师在闲聊的时候说，“学了这么多年唯物主义，觉得自己在唯心主义路上越走越远了。”</p>
<p>现在仔细体会一下，唯物主义用冷冰冰的、超越情感的视角来看事情是多么反人类。从自己内心出发去感悟这个世界则简单许多，负担也轻了很多。也许这是一种自我退化？</p>
<p>彼时我是“历史科代表”，很喜欢这位年轻的老师。她名字很美，取自于诗经“燕燕于飞”。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符编码的过程]]></title>
        <id>https://smartchaos.github.io/zi-fu-bian-ma-de-guo-cheng</id>
        <link href="https://smartchaos.github.io/zi-fu-bian-ma-de-guo-cheng">
        </link>
        <updated>2019-04-12T02:11:57.000Z</updated>
        <content type="html"><![CDATA[<p>最近在看《Java核心技术-卷1-基础知识》，对于java使用的Utf-16编码有诸多疑惑，其中一点就来自于对字符编码过程的缺乏了解。计算机系统里面的字符编码大约涉及下面几个流程：</p>
<p><img src="https://smartchaos.github.io//post-images/1555035175019.png" alt="字符编码过程" loading="lazy"><br>
通过这张图，可以比较容易了解到unicode和utf-8的关系，两者处于不同的概念层次上面，前者是形成CCS过程：将字符集里的字符映射成为一个整数, 这个整数又被成为Code Point。而后者则是将前面映射的整数映射成有限长度的比特值（CEF）的过程, 每个最小单元成为一个Code Unit。<br>
值得一提的是CEF是逐渐演化出来的概念，早期的ASCII编码可以理解为既包含CCS过程也包含CEF过程。从解决问题的角度，这是“增加一层抽象”解决问题的一个案例。<br>
详细了解可以参考：<a href="https://github.com/acmerfight/insight_python/blob/master/Unicode_and_Character_Sets.md">Insight Python-字符编码</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于命名的BAD CASE]]></title>
        <id>https://smartchaos.github.io/guan-yu-ming-ming-de-bad-case</id>
        <link href="https://smartchaos.github.io/guan-yu-ming-ming-de-bad-case">
        </link>
        <updated>2019-04-02T00:00:46.000Z</updated>
        <content type="html"><![CDATA[<p>昨天在对接组内一个同事的接口的时候发现一个问题：他有些命名习惯很怪。</p>
<ol>
<li>名字起得“大”而“远”，例如目前做的是一个服务集成的HUB服务，他的命名是“<strong>marketing</strong>”或者“<strong>stastics</strong>”再甚至是“<strong>marketing-data</strong>”。这些名字要么和当前服务没什么关系，要么涵盖的范围太广，缺乏真实的业务含义。初衷可能是想起一个将来“不后悔”的名字。</li>
<li>用间接的业务目的为行为命名，例如有个枚举字段叫做<code>actionType</code>, 用于标识用户的行为模式，他定义的两个枚举一个叫做<code>lucky_draw</code>一个叫做<code>dispatch_award</code>。但实际的业务行为是，用户中奖之后通过不同的渠道“留资”（留资是得奖的必要条件之一）。但实际上他用了间接业务目的来命名，而业务目的会随不同时间、不同群体变化。这里记录发生了什么更为合适。</li>
</ol>
<p>深层次来看，这可能是思维习惯的问题：&quot;<strong>长远的目标干扰，导致不能很好立足于当下；对业务理解程度不足，导致对某些业务理解片面化。</strong>&quot;<br>
平衡当下和远期目标确实是难题，但是骛远而不立足好当下是不可取的，不踏踏实实理解好业务场景并好好思考和抽象也是不足取的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于表述和物化目标]]></title>
        <id>https://smartchaos.github.io/guan-yu-biao-shu-he-wu-hua-mu-biao</id>
        <link href="https://smartchaos.github.io/guan-yu-biao-shu-he-wu-hua-mu-biao">
        </link>
        <updated>2019-03-26T23:48:08.000Z</updated>
        <content type="html"><![CDATA[<p>昨天在和人店技术沟通的时候发现对于一个崭新的“营销中台故事”，大家似乎没什么感知，反馈是营销这个主题太大了，并没有发掘落足点在哪里。</p>
<p>而从我这边来看落足点似乎又很清晰：我们要帮助市场营销人员提效。这个提效在我们中台视角会有两个发展方向，一个是通过“范式化”，让工具和模式尽可能做到复用，满足多数营销场景诉求；第二个则是反馈机制的建立，我们希望通过建立ROI机制，让营销也能够迭代。</p>
<p>问题出在哪里呢？没有表述清楚还是因为大家不熟悉这个领域需要物化？经过后面的讨论，我想可能是后者，大家需要将自己熟悉的现实场景映射到抽象的框架之中，但在听我讲PPT的时候却没能够建立好这种联系。<br>
这种情境是不是有好的改进方式呢？面向不同的用户群，表述方式需要作出明显区分，否则难免会出现理解的断层。可以想到的正面例子是肯尼迪总统的目标表述：“在未来10年内，把一个美国人送上月球，并使他重返地面。”这个目标面向的是非专业领域的广罗大众，这句话做到了清晰易懂易于传播。而我似乎也需要做一个这样的物化表述，也许是：在两年之内，营销中台要让所有的市场运营部门裁员50%？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode刷题记-004]]></title>
        <id>https://smartchaos.github.io/leetcode-shua-ti-ji-004</id>
        <link href="https://smartchaos.github.io/leetcode-shua-ti-ji-004">
        </link>
        <updated>2019-03-08T00:18:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="问题">问题</h2>
<p><a href="">两个有序数组寻找中间值问题</a></p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路一-借鉴有序链表合并的思路">思路一， 借鉴有序链表合并的思路</h3>
<p>虽然leetcode标记为困难。但实际上很容易会想到“有序链表合并”的思路，在这个思路的基础之上记录下来中间值位置。对于中间值位置，由于在两个数组的长度之和是偶数的时候，需要取中间前后的两个数值计算中间值，所以需要记录前后两个值。附代码：</p>
<pre><code class="language-java"> public double findMedianSortedArrays(int[] nums1, int[] nums2) {
         int totalLength = nums1.length + nums2.length;
        boolean oddFlag = totalLength % 2 == 1;
        final int middleVal = oddFlag ? totalLength / 2 + 1 : totalLength / 2 + 1;

        //navigate likes two linklists merging
        int countIndex = 1, idx1 = 0, idx2 = 0;
        int midPrev = 0, current = 0;

        while (true) {
            midPrev = current;
            if (idx1 &lt; nums1.length &amp;&amp; idx2 &lt; nums2.length) {
                if (nums1[idx1] &lt;= nums2[idx2]) {
                    current = nums1[idx1];
                    idx1++;
                } else {
                    current = nums2[idx2];
                    idx2++;
                }
            } else if (idx1 &gt;= nums1.length) {
                current = nums2[idx2];
                idx2++;
            } else {
                current = nums1[idx1];
                idx1++;
            }
        
            if (countIndex == middleVal) {
                return oddFlag ? current : (midPrev + current) / 2.0;
            }
            countIndex++;
        }
    }
</code></pre>
<p>这里需要说明的是midPrev记录前值，current记录当前值，总长是奇数长度的只需要关注current即可，否则需要用于加和求中间值，也就是<code>return oddFlag ? current : (midPrev + current) / 2.0</code></p>
<blockquote>
<p>Runtime: 24 ms, faster than 94.52% of Java online submissions for Median of Two Sorted Arrays.<br>
Memory Usage: 49 MB, less than 58.57% of Java online submissions for Median of Two Sorted Arrays.	<br>
不幸的是，这个答案是错的！时间复杂度是O(m+n), 而不是O(log(m+n))。LeetCode居然没能够检测出来。</p>
</blockquote>
<h3 id="思路二-利用有序特征二分">思路二 利用有序特征二分</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode刷题记-003]]></title>
        <id>https://smartchaos.github.io/leetcode-shua-ti-ji-003</id>
        <link href="https://smartchaos.github.io/leetcode-shua-ti-ji-003">
        </link>
        <updated>2019-03-05T09:07:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2>
<p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">最大不重复子串问题</a></p>
<h2 id="解题思路">解题思路</h2>
<ol>
<li>方案一：借助Set判断是否有重复， 通过游标j巡回判断， 实际上是一种暴力破解的思路</li>
</ol>
<pre><code class="language-java">   public static int lengthOfLongestSubstring(String s) {
        if (s.length() == 0) {
            return 0;
        }
        int lengthOfRes = 0;
        Set&lt;Character&gt; set = new HashSet&lt;&gt;();

        int length = s.length();
        for (int i = 0; i &lt; length; i++) {
            set.add(s.charAt(i));
            int j = i + 1;
            while (j &lt; s.length() &amp;&amp; !set.contains(s.charAt(j))) {
                set.add(s.charAt(j));
                if (j - i &gt; lengthOfRes) {
                    lengthOfRes = j - i;
                }
                j++;
            }
            set.clear();
        }
        return lengthOfRes + 1;
    }
</code></pre>
<p>结果实际上很不理想, 时间复杂度处于后1/3, 内存占用更没法看了。内存占用这点实际上是在预期之内的</p>
<blockquote>
<p>Runtime: 61 ms, faster than 22.26% of Java online submissions for Longest Substring Without Repeating Characters.<br>
Memory Usage: 39.3 MB, less than 20.73% of Java online submissions for Longest Substring Without Repeating Characters.</p>
</blockquote>
<p>反思下这个算法性能浪费在哪里了？对于已经具备的计算结果利用率不高可能是关键问题。例如abcdeabc这个case， abcde作为一个整体是没有重复字符的，接下来遇到了字母a，我们可能只需要把“滑动窗口”向右平移就好了，而不是重置到字母b，重新计算bcde是否有重复。于是有了方案2</p>
<ol start="2">
<li>方案二：</li>
</ol>
<pre><code class="language-java">public int lengthOfLongestSubstring(String s) {
        int length = s.length();
        if (length &lt;= 1) {
            return length;
        }
        int ans = 0;
        Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;(length);
        for (int i = 0, j = 0; j &lt; length; j++) {
            char currChar = s.charAt(j);
            if (window.containsKey(currChar)) {
                i = Math.max(window.get(currChar)+1, i);
            }
            ans = Math.max(ans, j - i + 1);
            window.put(currChar, j);
        }
        return ans;
    }
</code></pre>
<p>这里最关键的是<code>i = Math.max(window.get(currChar), i);</code>这一句，这决定了窗口起始位置移动到哪里。<br>
这个执行的结果大致如图：<br>
<img src="https://smartchaos.github.io//post-images/1560395089096.png" alt="" loading="lazy">，内存占用排名在前10%</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode刷题记-002]]></title>
        <id>https://smartchaos.github.io/leetcode-shua-ti-ji-002</id>
        <link href="https://smartchaos.github.io/leetcode-shua-ti-ji-002">
        </link>
        <updated>2019-03-05T05:08:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="问题">问题</h2>
<p><a href="https://leetcode.com/problems/add-two-numbers/">两个链表相加问题，情境类似于十进制大数加法</a></p>
<h2 id="解决方案">解决方案</h2>
<h3 id="原始方案">原始方案</h3>
<p>问题难点在于边界，直接上代码</p>
<pre><code class="language-java">public ListNode addTwoNumbers(ListNode l1, ListNode l2) {int carryFlag = 0, plusHolder;
        ListNode res = null;
        ListNode curPos = null;
        while (true) {
            plusHolder = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + carryFlag;
            carryFlag = plusHolder / 10;
            ListNode newNode = new ListNode(carryFlag == 0 ? plusHolder : (plusHolder - 10));
            if (res == null) {
                res = newNode;
                curPos = res;
            } else {
                curPos.next = newNode;
                curPos = curPos.next;
            }
            if (l1 != null)
                l1 = l1.next;
            if (l2 != null)
                l2 = l2.next;
            if (l1 == null &amp;&amp; l2 == null &amp;&amp; carryFlag != 1) {
                return res;
            }
        }
    }
</code></pre>
<p>执行结果如下：</p>
<blockquote>
<p>Runtime: 19 ms, faster than 99.90% of Java online submissions for Add Two Numbers.<br>
Memory Usage: 48.2 MB, less than 17.15% of Java online submissions for Add Two Numbers.</p>
</blockquote>
<p>从结果来看广大网友似乎更多是在节省空间复杂度上下了功夫。</p>
<h3 id="改进思路">改进思路，</h3>
<p>是不是可以利用L1或者L2保存结果以节省空间呢？也就是以常见的merge链表的思路去做</p>
<pre><code class="language-java">public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        int carryFlag = 0, plusHolder;
        ListNode prevPos = l1;
        ListNode headPos = l1;
        while (true) {
            plusHolder = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + carryFlag;
            carryFlag = plusHolder / 10;
            if (l1 == null) {
                ListNode newNode = new ListNode(carryFlag == 0 ? plusHolder : (plusHolder - 10));
                prevPos.next = newNode;
                l1 = prevPos.next;
            } else {
                l1.val = carryFlag == 0 ? plusHolder : (plusHolder - 10);
            }
            prevPos = l1;
            l1 = l1.next;
            if (l2 != null)
                l2 = l2.next;
            if (l1 == null &amp;&amp; l2 == null &amp;&amp; carryFlag != 1) {
                return headPos;
            }
        }
    }
</code></pre>
<p>结果在执行\空间占用上面确有优化：</p>
<blockquote>
<p>Runtime: 19 ms, faster than 99.90% of Java online submissions for Add Two Numbers.<br>
Memory Usage: 47.8 MB, less than 41.60% of Java online submissions for Add Two Numbers.</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode刷题记-001]]></title>
        <id>https://smartchaos.github.io/leetcode-shua-ti-ji-001</id>
        <link href="https://smartchaos.github.io/leetcode-shua-ti-ji-001">
        </link>
        <updated>2019-03-05T02:09:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="问题">问题：</h2>
<p><a href="https://leetcode.com/problems/two-sum/">两数相加等于目标值</a></p>
<h2 id="解题思路">解题思路</h2>
<ol>
<li>容易想到的是双层循环, 时间复杂度O(n^2)。需要关注的是题目提示只有一个答案，并且暗示不该出现自己和自己相加的情形（影响到边界处理条件）。代码如下：</li>
</ol>
<pre><code class="language-java">public int[] twoSum(int[] nums, int target) {
        int j = nums.length - 1;
        do {
            int i = 0;
            while (i &lt; j) {
                if (nums[i] + nums[j] == target) {
                    return new int[]{i, j};
                }
                i++;
            }
        } while (--j &gt; 0);
        new IllegalArgumentException(&quot;No two sum solution&quot;);
    }
</code></pre>
<blockquote>
<p>Runtime: 20 ms, faster than 41.25% of Java online submissions for Two Sum.<br>
Memory Usage: 38.5 MB, less than 45.94% of Java online submissions for Two Sum.</p>
</blockquote>
<ol start="2">
<li>容易想到的还有先用target与数组里的值做差，再借助Map这种数据结构, 遍历原数组寻找“配对”值下标。时间复杂度变为O(n)</li>
</ol>
<pre><code class="language-java">public int[] twoSum(int[] nums, int target) {
        Map&lt;Integer, Integer&gt; diffMap = new HashMap&lt;&gt;(nums.length);
        for (int i = 0; i &lt; nums.length; i++) {
            diffMap.put(target - nums[i], i);
        }
        for (int i = 0; i &lt; nums.length; i++) {
            Integer oriIndex = diffMap.get(nums[i]);
            if (oriIndex != null &amp;&amp; i != oriIndex) {
                return new int[]{i, oriIndex};
            }
        }
        return new int[2];
    }
</code></pre>
<blockquote>
<p>Runtime: 3 ms, faster than 99.77% of Java online submissions for Two Sum.<br>
Memory Usage: 38.3 MB, less than 63.08% of Java online submissions for Two Sum.</p>
</blockquote>
<ol start="3">
<li>看了官方的solution集，发现还有更加紧凑的解法，只需要一次循环。思路是边循环边设置并检查map，如果加和等于target则终止，最坏情况是第一个元素和最后一个元素匹配。</li>
</ol>
<pre><code class="language-java">public int[] twoSum(int[] nums, int target) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(nums.length);
        for (int i = 0; i &lt; nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[]{map.get(complement), i};
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException(&quot;No two sum solution&quot;);
    }
</code></pre>
<blockquote>
<p>Runtime: 3 ms, faster than 99.77% of Java online submissions for Two Sum.<br>
Memory Usage: 39.2 MB, less than 21.98% of Java online submissions for Two Sum.</p>
</blockquote>
<p>有意思的是，内存使用量比方案2多，会是什么原因呢？</p>
]]></content>
    </entry>
</feed>