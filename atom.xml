<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://smartchaos.github.io/</id>
    <title>沉舟录</title>
    <updated>2020-06-28T13:05:37.350Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://smartchaos.github.io/"/>
    <link rel="self" href="https://smartchaos.github.io/atom.xml"/>
    <subtitle>沉舟侧畔千帆过，病树前头万木春</subtitle>
    <logo>https://smartchaos.github.io/images/avatar.png</logo>
    <icon>https://smartchaos.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 沉舟录</rights>
    <entry>
        <title type="html"><![CDATA[产业互联网是什么]]></title>
        <id>https://smartchaos.github.io/DLGTMZKod/</id>
        <link href="https://smartchaos.github.io/DLGTMZKod/">
        </link>
        <updated>2020-06-28T12:55:37.000Z</updated>
        <summary type="html"><![CDATA[<p>这是在团队内部进行的一次分享。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这是在团队内部进行的一次分享。</p>
<!-- more -->
<h2 id="产业互联网是什么">产业互联网是什么</h2>
<h3 id="四个互联网">四个互联网</h3>
<ol>
<li>消费互联网</li>
<li>产业互联网</li>
<li>工业互联网</li>
<li>政企互联网</li>
</ol>
<h3 id="产业互联网的定义">产业互联网的定义</h3>
<p>业界并没有一个有共识的定义，下面我摘抄了几种表述：</p>
<blockquote>
<p>明显区别于消费互联网的企业级互联网应用大市场，涵盖企业生产经营活动的全生命周期，通过网络提供全面的感知、移动的应用、云端的资源和大数据分析，<strong>重构</strong>企业内部的组织架构，生产、经营、融资模式以及企业与外部的协同交互，实现产业间的<strong>融合</strong>与产业生态的<strong>协同发展</strong>。</p>
</blockquote>
<blockquote>
<p>产业互联网不仅是企业内部互联网化，而是通过在研发、生产、交易、流通和融资等各个环节的网络渗透从而达到提升效率、优化资源配置，更是产业链互联网化，打通上下游，站在产业角度重塑企业核心竞争力。它的商业模式就是通过传统企业与互联网的融合，寻求全新的管理与服务模式，为消费者提供更好的服务体验，创造出更高价值的产业形态。</p>
</blockquote>
<p>总结来看，2B-2C的互联网化、企业内部的资源融合和重构以推动效率的提升和成本的下降、产业全链路的协同发展是要点。</p>
<h3 id="涵盖内容">涵盖内容</h3>
<h4 id="四个重塑">四个重塑</h4>
<blockquote>
<p>**研发重塑：**由单向度精英式引导向全互动草根式众包变革。</p>
<p>**生产重塑：**由大规模标准化生产向大规模柔性定制生产变革。例如海尔的智能工厂。</p>
<p>**销售重塑：**由简单的线下推进向融合式全渠道营销转变。</p>
<p>**协同重塑：**由企业内部协作向全产业链协同变革。</p>
</blockquote>
<h4 id="去三化">去三化</h4>
<p>陈威如的《平台转型》里提到的去三化：</p>
<blockquote>
<p><strong>第一，去中间化，直接连接—缩短价值</strong></p>
<p><strong>第二，去中心化，激发多元—调动资源，解放生产力。</strong> <em>滴滴</em></p>
<p><strong>第三，去边界化，协同整合—形成生态圈，跨界整合。</strong></p>
</blockquote>
<h2 id="产业互联网的底层逻辑是什么">产业互联网的底层逻辑是什么？</h2>
<blockquote>
<p><strong>消费互联网，线上系统是线下系统的镜像；</strong></p>
<p><strong>产业互联网，线下系统是线上系统的镜像。</strong></p>
</blockquote>
<h3 id="消费互联网的底层逻辑">消费互联网的底层逻辑</h3>
<ol>
<li>按照线下实体的系统和要素，建立线上的系统镜像（与线下一致）；</li>
<li>搜集线下需求端与供给端数据；</li>
<li>匹配供需数据后进行交付（可形成或不形成交易）；</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/06/28/hw81JFCtYLSom45.jpg" alt="img" loading="lazy"></figure>
<p>从这个逻辑来看，消费互联网线上成本低、容易复制迁移，流量为王——寡头竞争。</p>
<p>例1：电商——淘宝</p>
<ol>
<li>建立线上店铺，完成了零售系统的线上镜像：店铺、陈列、商品、价格、顾客服务（亲）、支付、交付（含运输）等成套与线下完全一致的系统镜像；</li>
<li>B端上传商品的数据（基本信息和价格）即供给端数据，C端用户自行按需输入需求数据；</li>
<li>线上系统进行供需匹配，以实现线上完成交易，线下系统提供交付。</li>
</ol>
<h3 id="产业互联网的底层逻辑">产业互联网的底层逻辑</h3>
<ol>
<li>按照线下实体的系统的要素，在线上建立要素的镜像（只建要素不建系统）；</li>
<li>建立线上新系统（以线下系统为基础或全新皆可）；</li>
<li>将线下要素的镜像导入新系统进行模拟并生成反向控制线下要素的指令；</li>
<li>线下要素重新按照线上系统的指令协同工作或完成服务过程；</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2020/06/28/1gTzqOhL4xoaCsY.jpg" alt="img" loading="lazy"></figure>
<p>垂直化显著，各个行业具备不同特征，产业链条长、门槛高——众多独角兽。</p>
<p>例2： PDD——C2M（Customer to Manufacturer）F2B2C</p>
<p>平台+工厂模式，以平台大数据对用户需求的分析以及社交、社群对用户需求的感知为基础，将用户需求汇总处理形成订单，直接交付工厂，最终由平台整合的<a href="http://baike.eastmoney.com/item/%E4%BE%9B%E5%BA%94%E9%93%BE">供应链</a>完成用户交付，简化中间环节。</p>
<p>前端是更深层次的用户触达。与用户建立高粘性，能够实实在在激发、感知用户需求，将电商模式的核心从“以流量为中心”推升到“以用户为中心”，这是C2M模式的底层逻辑。</p>
<p>后端是更加极致的<a href="http://baike.eastmoney.com/item/%E4%BA%A7%E4%B8%9A%E9%93%BE">产业链</a>接。在C2M模式下，最大的阻碍来自用户需求交付的效率，在国内电商市场，用户很难接受动辄十几天的收货时间，只有在产业端用数字化方式直接连接工厂，才能将交付效率提升到用户的接受范围之内，这是C2M模式的底层支撑。</p>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2020/06/28/xtpyNuFQO65mVGC.jpg" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2020/06/28/31oe4O2gqD9fESG.png" alt="img" loading="lazy"></figure>
<p>”家卫士“扫地机器人， 288，1/4的价格， 富余生产力价值的再创造。</p>
<p>例3： 阿里巴巴——躺平设计师平台 + 三维家 + 阿里供应链中台等基础设施 + 居然之家/红星美凯龙等线下卖场</p>
<figure data-type="image" tabindex="5"><img src="https://i.loli.net/2020/06/28/asGuHCAEo6byVJR.jpg" alt="img" loading="lazy"></figure>
<p>阿里巴巴 + 爱空间？</p>
<p>例4： 贝壳找房——人店</p>
<p>贝壳找房的逻辑：</p>
<ol>
<li>线下要素提取， 人/房/客</li>
<li>规则提炼升华：ACN</li>
<li>线下数据上传：人店SAAS</li>
<li>线上系统调度线下作业： 人店平台</li>
</ol>
<figure data-type="image" tabindex="6"><img src="https://i.loli.net/2020/06/28/RHLjG8tVSXeZrlE.jpg" alt="贝壳找房ACN：从基础设施颠覆传统经纪行业的一剂猛药" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://i.loli.net/2020/06/28/xMnYr9qPQhzEBpi.jpg" alt="img" loading="lazy"></figure>
<p>所以：贝壳找房不是“裁判员 + 运动员”， 而是提供了“足球场和运行规则”</p>
<h2 id="我们需要怎样的能力模型">我们需要怎样的能力模型</h2>
<p>祝旭巍：产业互联网开发人员的四力模型</p>
<figure data-type="image" tabindex="8"><img src="https://i.loli.net/2020/06/28/sV1ZMSvAocFd9nU.png" alt="image-20200628181535442" loading="lazy"></figure>
<p>新装修整理的技术价值观：</p>
<blockquote>
<p>能冲锋，敢担当；有承诺，定做到；</p>
<p>多调研，深思考；做拆解，以细致；</p>
<p>乐协作，愿分享；求卓越，寻突破。</p>
</blockquote>
<p>参考资料：</p>
<ol>
<li>https://zhuanlan.zhihu.com/p/74853828</li>
<li><strong>张梓钧</strong>：<a href="https://m.hbrchina.org/article/175">产业互联网蓝海前景的四大方向（哈佛商业评论）</a></li>
<li><a href="http://www.woshipm.com/it/633731.html">产业互联网三问：是什么？机会在哪？如何实施？</a></li>
<li><a href="https://baijiahao.baidu.com/s?id=1657588543641885199&amp;wfr=spider&amp;for=pc">房地产市场温度下降，从媒体、技术、标签、产品四方面应对</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我家小朋友讲的第一个故事]]></title>
        <id>https://smartchaos.github.io/MN_6DER5Y/</id>
        <link href="https://smartchaos.github.io/MN_6DER5Y/">
        </link>
        <updated>2020-02-12T03:21:13.000Z</updated>
        <content type="html"><![CDATA[<p>2岁10个月的小朋友编的第一个故事：</p>
<blockquote>
<p>从前有只大鸭子<br>
背上背着一个大菠萝<br>
大菠萝被大灰狼抢走啦<br>
大菠萝被大灰狼丢啦</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swagger通过example属性Mock复杂数据]]></title>
        <id>https://smartchaos.github.io/VDBSG093/</id>
        <link href="https://smartchaos.github.io/VDBSG093/">
        </link>
        <updated>2020-02-03T12:51:31.000Z</updated>
        <content type="html"><![CDATA[<p>通过example属性传递常规类型数据是相对比较容易的，例如字符串、数值等，直接填写值即可，对于复杂类型，笔者整理了一些经验可供分享。</p>
<ol>
<li>Date类型，设置dataType为Date, example填写参照时间，例如<pre><code class="language-java">@ApiModelProperty(value = &quot;目标送达时间&quot;, dataType = &quot;Date&quot;, example = &quot;2019-10-20 10:00:00&quot;)
 private String targetArriveTime;
</code></pre>
</li>
<li>List和Set的简单类型，设置dataType为相应的类型，例如<code>java.lang.Xx</code>, example里面填写值<code>[\&quot;str1\&quot;, \&quot;str2\&quot;]</code>即可, 例如Integer的列表可以这样：<pre><code class="language-java">@ApiModelProperty(name = &quot;测试id&quot;, required = false, dataType = &quot;java.lang.Integer&quot;, example = &quot;[1,2,3]&quot;)
 private List&lt;Integer&gt; testIds;
</code></pre>
</li>
<li>List传递复杂类型，可以直接填写dataType， 无需设置example, 这个值的获取可以从具体的类里面取得场景2可以认为是特例。例如<pre><code class="language-java">/**
  * 商品列表
  */
 @ApiModelProperty(value = &quot;配送商品列表&quot;, dataType = &quot;com.ke.utopia.scm.tms.base.vo.ProductItem&quot;)
 private List&lt;ProductItem&gt; productItemList;
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020春节回乡见闻]]></title>
        <id>https://smartchaos.github.io/woc3iVrWw/</id>
        <link href="https://smartchaos.github.io/woc3iVrWw/">
        </link>
        <updated>2020-02-02T06:09:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="经济篇">经济篇</h2>
<h3 id="大堂兄的新零售">大堂兄的“新零售”</h3>
<h3 id="三堂兄的大理石生意">三堂兄的大理石生意</h3>
<h2 id="生活">生活</h2>
<h3 id="新农村基础设施建设">新农村基础设施建设</h3>
<h3 id=""></h3>
<h2 id="疫情">疫情</h2>
<h3 id="封村">封村</h3>
<h3 id="人情">人情</h3>
<h2 id="启发">启发</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Read Digest] 2020-01]]></title>
        <id>https://smartchaos.github.io/rOIE_LP-e/</id>
        <link href="https://smartchaos.github.io/rOIE_LP-e/">
        </link>
        <updated>2020-01-08T08:25:34.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p><a href="https://mp.weixin.qq.com/s/2Cs8ybu5Kg9QYr5Jgyu6VA"><strong>毕业10年才懂，会升层思考，工作有多轻松</strong></a></p>
<ul>
<li>问题的本质是事物的矛盾，准确定义问题是成功的开始。</li>
<li>准确定义问题需要从定性和定量两个角度进行，核心关注的是主要/次要、紧急/不紧急，其中重要性往往用预期和现实的落差衡量，需要通过度量的方式明晰。</li>
<li>问题一般可以划分为三类：恢复原状型、防范风险型、追求理想型，不同类别的问题需要采用不同的手段处理。</li>
<li>问题定义里常见问题是<strong>把方法和手段当问题</strong>、<strong>误把挑战当问题</strong>、<strong>思考问题缺少时间维度</strong></li>
<li>升层思考:  我们不能只局限于问题本身，还需要看到问题背后的问题，然后才能更容易的找到更多的解决方案。缺乏升层思考的升维思考是不完整的自顶向下。</li>
<li>升层思考问题，升维思考手段/方法。</li>
</ul>
</li>
<li>
<p><a href="https://onregularinvesting.com/#/cn/"><strong>定投改变命运</strong></a> (又名《让时间陪你慢慢变富》)</p>
<ul>
<li>是什么
<ul>
<li>定投：针对某个投资标的在很长的时间内定期投资一定的金额。</li>
<li>定投是趋势投资而不是价值投资</li>
</ul>
</li>
<li>为什么
<ul>
<li>效果：通过数据反馈的长期收益效果显著。长期是指超过标的两个<strong>大周期</strong>。</li>
<li>经济周期的形成，本质上是参与经济的多方协作时而协调、时而不协调造成的。</li>
<li>用钱赚钱的逻辑：个人时间有限问题。</li>
<li>个人商业模式升级：时间多次售卖、钱生钱。</li>
<li>p = δ + α - γ  (performance = 市场整体成绩+理想个体收益-犯错成本)</li>
</ul>
</li>
<li>怎么做
<ul>
<li>定投策略无需改良，在混沌状态下，改良都是徒劳。</li>
<li>定投标的的选择策略：盲从。盲从那些已经展现长期成功业绩的真正成功投资者的建议。</li>
<li>鸡蛋不放在一个篮子里，做综合指标的投资。</li>
<li>定投策略的最终成功要义：<strong>谨慎选择长期持有</strong></li>
</ul>
</li>
<li>基础原理
<ul>
<li>投资领域第一性原理没有得到深入思考是问题产生的缘由</li>
<li>销售就是购买他人的时间再卖出去很多次</li>
<li>人本身很不靠谱:137+——种心理偏差</li>
<li>越是早期的错误所造成的长期代价越高 —— 因为在长期之后，那些代价会被无限放大。好的策略是行为盲从、内心推断、长期观察和学习</li>
<li><strong>边界思考，长期视角，宏观观察</strong>，这三个概念组合在一起甚至可以改变一个人的性格。</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一文读懂Java的Classloader机制]]></title>
        <id>https://smartchaos.github.io/yi-wen-du-dong-java-de-classloader-ji-zhi/</id>
        <link href="https://smartchaos.github.io/yi-wen-du-dong-java-de-classloader-ji-zhi/">
        </link>
        <updated>2019-07-25T02:53:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="java-classloader是怎样定义的">Java Classloader是怎样定义的</h2>
<p>从wikipedia上我们可以找到Java Classloader的定义：</p>
<blockquote>
<p>The Java Class Loader is a part of the Java Runtime Environment that dynamically loads Java classes into the Java Virtual Machine.</p>
</blockquote>
<p>这个定义从用途角度出发明确了Java Classloader的核心职责：将Java class动态加载到JVM中。<br>
从概念上看，classloader和JVM以及JRE的关系如下图<br>
<img src="https://smartchaos.github.io//post-images/1564105434232.png" alt="classloader和JVM的关系" loading="lazy"><br>
从功能视角来看，classloader提供了一种能力，把操作系统里的文件和文件格式差异抹平，以统一的class格式提供给JVM。如下图：<br>
<img src="https://smartchaos.github.io//post-images/1564106049903.png" alt="classloader的功能视角" loading="lazy"></p>
<h2 id="classloader的分类">classloader的分类</h2>
<p>JDK为我们提供了多种classloader, 从上到下依次是：</p>
<ol>
<li>Bootstrap Classloader, 这个是根加载器，加载java_home/lib下的类库，JDK专用，开发者无法直接获取和使用。</li>
<li>Extension Classloader是扩展类加载器，负责加载java_home/lib/ext路径下的类和系统变量java.ext.dir定义路径下的类。这个有了一定的自由度，并且支持开发者直接访问和使用。</li>
<li>App Classloader是应用类加载器（又称系统类加载器），负责加载classpath下的类库，开发者可以直接使用。<br>
除此之外还可以自定义自己的类加载器 。这些类加载器的层级结构如下图：<br>
<img src="https://smartchaos.github.io//post-images/1578385308928.png" alt="classloader的层级关系" loading="lazy"></li>
</ol>
<h2 id="classloader的工作过程">classloader的工作过程</h2>
<p>classloader的工作过程大致是这样的：</p>
<ol>
<li>找到要加载的类 findClass</li>
<li>对要加载的类进行增删改</li>
<li>加载类 loadClass<br>
我们在实现自己的classloader的过程中一般也就是根据需要实现相关的操作。</li>
</ol>
<h2 id="双亲委派机制">双亲委派机制</h2>
<p>多个classloader在加载类的过程中，难免会遇到冲突问题：同样路径和名字的类，到底由谁来加载呢？</p>
<p>JDK提供的解决方案是“双亲委派”，以确定classloader的优先级。<br>
具体策略是在子classloader中发现某个类并不着急加载它，而是委托给它的parent，parent classloader也不着急加载，也是优先去自己的parent classloader询问。如此递归一直找到Bootstrap Classloader, 如果路径中都找不到，那么最末端的子classloader加载，否则就是最上游的类加载器加载。</p>
<p>这个模型的设定是：你写的不如官方的靠谱，核心功能不要随便改写，否则后果不可预料。初衷无疑是为了安全和可靠。</p>
<h2 id="现实世界的classloader">现实世界的classloader</h2>
<p>现实世界中有很多类型的classloader，下面介绍两个在项目开发中常见的两个：</p>
<h3 id="spring和sring-mvc的classloader">Spring和Sring mvc的classloader</h3>
<h3 id="spring-boot-devtools的classcloader">Spring boot devtools的classcloader</h3>
<h2 id="什么时候你需要定义自己的classloader">什么时候你需要定义自己的classloader</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[中关村软件园孵化器楼停车攻略]]></title>
        <id>https://smartchaos.github.io/zhong-guan-cun-ruan-jian-yuan-yi-qi-xi-nan-ting-che-gong-lue/</id>
        <link href="https://smartchaos.github.io/zhong-guan-cun-ruan-jian-yuan-yi-qi-xi-nan-ting-che-gong-lue/">
        </link>
        <updated>2019-05-21T00:30:15.000Z</updated>
        <content type="html"><![CDATA[<p>近期搬到新办公地点，是除了公共配套之外都很不错的办公区域。公共配套中尤为突出的是交通问题，作为开车一族（就我而言不开车更难受，几公里的距离需要倒3辆车+步行1km），用两天时间把周边转了个遍，整理出一个简单的停车攻略。</p>
<h2 id="软件园内">软件园内</h2>
<p>这里的特点是每栋大厦自成体系，宁可空着车位也要守住自己的“一亩三分地”。所以内部基本上没有对外开放的停车场，唯一的清流是“数字山谷大厦”，</p>
<blockquote>
<p>停车费标准：无包月，大概200+车位。<br>
地面停车：7-19点1元/15分钟, 不封顶；19-次日7点3元/h, 不封顶。<br>
地库停车：7-19点1.5元/15分钟, 不封顶；19-次日7点4元/h，不封顶。</p>
</blockquote>
<p>除了这个选择之外，还可以停在东南侧环宇大厦往东的路边（算园区路边停车位），收费0.5元/15分钟，院区内公共停车位实际数量比较少，难以找到。</p>
<h2 id="周边停车场">周边停车场</h2>
<ol>
<li>南面百旺绿茵停车场，价格4元每小时, 可以包月400，季付1000，车位比较充足，距离孵化器1.2km+。</li>
<li>东大停车场（西），包月300，车位总体充足，步行到孵化器900米。从这个停车场出去后的后厂村路左转车道常年拥堵，一般需要2-3个红绿灯才能通过。</li>
<li>西南侧软通动力南停车场，车入口接近浪潮大厦，东北角有个人行入口，200每月， 车位充足。需要注意的是这个停车场地面是土质的，下雨可能和泥。</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://smartchaos.github.io//post-images/1560395965166.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[唯物唯心]]></title>
        <id>https://smartchaos.github.io/wei-wu-wei-xin/</id>
        <link href="https://smartchaos.github.io/wei-wu-wei-xin/">
        </link>
        <updated>2019-04-23T07:17:20.000Z</updated>
        <content type="html"><![CDATA[<p>高中时一位历史老师在闲聊的时候说，“学了这么多年唯物主义，觉得自己在唯心主义路上越走越远了。”</p>
<p>现在仔细体会一下，唯物主义用冷冰冰的、超越情感的视角来看事情是多么反人类。从自己内心出发去感悟这个世界则简单许多，负担也轻了很多。也许这是一种自我退化？</p>
<p>彼时我是“历史科代表”，很喜欢这位年轻的老师。她名字很美，取自于诗经“燕燕于飞”。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符编码的过程]]></title>
        <id>https://smartchaos.github.io/zi-fu-bian-ma-de-guo-cheng/</id>
        <link href="https://smartchaos.github.io/zi-fu-bian-ma-de-guo-cheng/">
        </link>
        <updated>2019-04-12T02:11:57.000Z</updated>
        <content type="html"><![CDATA[<p>最近在看《Java核心技术-卷1-基础知识》，对于java使用的Utf-16编码有诸多疑惑，其中一点就来自于对字符编码过程的缺乏了解。计算机系统里面的字符编码大约涉及下面几个流程：</p>
<p><img src="https://smartchaos.github.io//post-images/1555035175019.png" alt="字符编码过程" loading="lazy"><br>
通过这张图，可以比较容易了解到unicode和utf-8的关系，两者处于不同的概念层次上面，前者是形成CCS过程：将字符集里的字符映射成为一个整数, 这个整数又被成为Code Point。而后者则是将前面映射的整数映射成有限长度的比特值（CEF）的过程, 每个最小单元成为一个Code Unit。<br>
值得一提的是CEF是逐渐演化出来的概念，早期的ASCII编码可以理解为既包含CCS过程也包含CEF过程。从解决问题的角度，这是“增加一层抽象”解决问题的一个案例。<br>
详细了解可以参考：<a href="https://github.com/acmerfight/insight_python/blob/master/Unicode_and_Character_Sets.md">Insight Python-字符编码</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于命名的BAD CASE]]></title>
        <id>https://smartchaos.github.io/guan-yu-ming-ming-de-bad-case/</id>
        <link href="https://smartchaos.github.io/guan-yu-ming-ming-de-bad-case/">
        </link>
        <updated>2019-04-02T00:00:46.000Z</updated>
        <content type="html"><![CDATA[<p>昨天在对接组内一个同事的接口的时候发现一个问题：他有些命名习惯很怪。</p>
<ol>
<li>名字起得“大”而“远”，例如目前做的是一个服务集成的HUB服务，他的命名是“<strong>marketing</strong>”或者“<strong>stastics</strong>”再甚至是“<strong>marketing-data</strong>”。这些名字要么和当前服务没什么关系，要么涵盖的范围太广，缺乏真实的业务含义。初衷可能是想起一个将来“不后悔”的名字。</li>
<li>用间接的业务目的为行为命名，例如有个枚举字段叫做<code>actionType</code>, 用于标识用户的行为模式，他定义的两个枚举一个叫做<code>lucky_draw</code>一个叫做<code>dispatch_award</code>。但实际的业务行为是，用户中奖之后通过不同的渠道“留资”（留资是得奖的必要条件之一）。但实际上他用了间接业务目的来命名，而业务目的会随不同时间、不同群体变化。这里记录发生了什么更为合适。</li>
</ol>
<p>深层次来看，这可能是思维习惯的问题：&quot;<strong>长远的目标干扰，导致不能很好立足于当下；对业务理解程度不足，导致对某些业务理解片面化。</strong>&quot;<br>
平衡当下和远期目标确实是难题，但是骛远而不立足好当下是不可取的，不踏踏实实理解好业务场景并好好思考和抽象也是不足取的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于表述和物化目标]]></title>
        <id>https://smartchaos.github.io/guan-yu-biao-shu-he-wu-hua-mu-biao/</id>
        <link href="https://smartchaos.github.io/guan-yu-biao-shu-he-wu-hua-mu-biao/">
        </link>
        <updated>2019-03-26T23:48:08.000Z</updated>
        <content type="html"><![CDATA[<p>昨天在和人店技术沟通的时候发现对于一个崭新的“营销中台故事”，大家似乎没什么感知，反馈是营销这个主题太大了，并没有发掘落足点在哪里。</p>
<p>而从我这边来看落足点似乎又很清晰：我们要帮助市场营销人员提效。这个提效在我们中台视角会有两个发展方向，一个是通过“范式化”，让工具和模式尽可能做到复用，满足多数营销场景诉求；第二个则是反馈机制的建立，我们希望通过建立ROI机制，让营销也能够迭代。</p>
<p>问题出在哪里呢？没有表述清楚还是因为大家不熟悉这个领域需要物化？经过后面的讨论，我想可能是后者，大家需要将自己熟悉的现实场景映射到抽象的框架之中，但在听我讲PPT的时候却没能够建立好这种联系。<br>
这种情境是不是有好的改进方式呢？面向不同的用户群，表述方式需要作出明显区分，否则难免会出现理解的断层。可以想到的正面例子是肯尼迪总统的目标表述：“在未来10年内，把一个美国人送上月球，并使他重返地面。”这个目标面向的是非专业领域的广罗大众，这句话做到了清晰易懂易于传播。而我似乎也需要做一个这样的物化表述，也许是：在两年之内，营销中台要让所有的市场运营部门裁员50%？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode刷题记-004]]></title>
        <id>https://smartchaos.github.io/leetcode-shua-ti-ji-004/</id>
        <link href="https://smartchaos.github.io/leetcode-shua-ti-ji-004/">
        </link>
        <updated>2019-03-08T00:18:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="问题">问题</h2>
<p><a href="">两个有序数组寻找中间值问题</a></p>
<h2 id="解题思路">解题思路</h2>
<h3 id="思路一-借鉴有序链表合并的思路">思路一， 借鉴有序链表合并的思路</h3>
<p>虽然leetcode标记为困难。但实际上很容易会想到“有序链表合并”的思路，在这个思路的基础之上记录下来中间值位置。对于中间值位置，由于在两个数组的长度之和是偶数的时候，需要取中间前后的两个数值计算中间值，所以需要记录前后两个值。附代码：</p>
<pre><code class="language-java"> public double findMedianSortedArrays(int[] nums1, int[] nums2) {
         int totalLength = nums1.length + nums2.length;
        boolean oddFlag = totalLength % 2 == 1;
        final int middleVal = oddFlag ? totalLength / 2 + 1 : totalLength / 2 + 1;

        //navigate likes two linklists merging
        int countIndex = 1, idx1 = 0, idx2 = 0;
        int midPrev = 0, current = 0;

        while (true) {
            midPrev = current;
            if (idx1 &lt; nums1.length &amp;&amp; idx2 &lt; nums2.length) {
                if (nums1[idx1] &lt;= nums2[idx2]) {
                    current = nums1[idx1];
                    idx1++;
                } else {
                    current = nums2[idx2];
                    idx2++;
                }
            } else if (idx1 &gt;= nums1.length) {
                current = nums2[idx2];
                idx2++;
            } else {
                current = nums1[idx1];
                idx1++;
            }
        
            if (countIndex == middleVal) {
                return oddFlag ? current : (midPrev + current) / 2.0;
            }
            countIndex++;
        }
    }
</code></pre>
<p>这里需要说明的是midPrev记录前值，current记录当前值，总长是奇数长度的只需要关注current即可，否则需要用于加和求中间值，也就是<code>return oddFlag ? current : (midPrev + current) / 2.0</code></p>
<blockquote>
<p>Runtime: 24 ms, faster than 94.52% of Java online submissions for Median of Two Sorted Arrays.<br>
Memory Usage: 49 MB, less than 58.57% of Java online submissions for Median of Two Sorted Arrays.	<br>
不幸的是，这个答案是错的！时间复杂度是O(m+n), 而不是O(log(m+n))。LeetCode居然没能够检测出来。</p>
</blockquote>
<h3 id="思路二-利用有序特征二分">思路二 利用有序特征二分</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode刷题记-003]]></title>
        <id>https://smartchaos.github.io/leetcode-shua-ti-ji-003/</id>
        <link href="https://smartchaos.github.io/leetcode-shua-ti-ji-003/">
        </link>
        <updated>2019-03-05T09:07:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2>
<p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">最大不重复子串问题</a></p>
<h2 id="解题思路">解题思路</h2>
<ol>
<li>方案一：借助Set判断是否有重复， 通过游标j巡回判断， 实际上是一种暴力破解的思路</li>
</ol>
<pre><code class="language-java">   public static int lengthOfLongestSubstring(String s) {
        if (s.length() == 0) {
            return 0;
        }
        int lengthOfRes = 0;
        Set&lt;Character&gt; set = new HashSet&lt;&gt;();

        int length = s.length();
        for (int i = 0; i &lt; length; i++) {
            set.add(s.charAt(i));
            int j = i + 1;
            while (j &lt; s.length() &amp;&amp; !set.contains(s.charAt(j))) {
                set.add(s.charAt(j));
                if (j - i &gt; lengthOfRes) {
                    lengthOfRes = j - i;
                }
                j++;
            }
            set.clear();
        }
        return lengthOfRes + 1;
    }
</code></pre>
<p>结果实际上很不理想, 时间复杂度处于后1/3, 内存占用更没法看了。内存占用这点实际上是在预期之内的</p>
<blockquote>
<p>Runtime: 61 ms, faster than 22.26% of Java online submissions for Longest Substring Without Repeating Characters.<br>
Memory Usage: 39.3 MB, less than 20.73% of Java online submissions for Longest Substring Without Repeating Characters.</p>
</blockquote>
<p>反思下这个算法性能浪费在哪里了？对于已经具备的计算结果利用率不高可能是关键问题。例如abcdeabc这个case， abcde作为一个整体是没有重复字符的，接下来遇到了字母a，我们可能只需要把“滑动窗口”向右平移就好了，而不是重置到字母b，重新计算bcde是否有重复。于是有了方案2</p>
<ol start="2">
<li>方案二：</li>
</ol>
<pre><code class="language-java">public int lengthOfLongestSubstring(String s) {
        int length = s.length();
        if (length &lt;= 1) {
            return length;
        }
        int ans = 0;
        Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;(length);
        for (int i = 0, j = 0; j &lt; length; j++) {
            char currChar = s.charAt(j);
            if (window.containsKey(currChar)) {
                i = Math.max(window.get(currChar)+1, i);
            }
            ans = Math.max(ans, j - i + 1);
            window.put(currChar, j);
        }
        return ans;
    }
</code></pre>
<p>这里最关键的是<code>i = Math.max(window.get(currChar), i);</code>这一句，这决定了窗口起始位置移动到哪里。<br>
这个执行的结果大致如图：<br>
<img src="https://smartchaos.github.io//post-images/1560395089096.png" alt="" loading="lazy">，内存占用排名在前10%</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode刷题记-002]]></title>
        <id>https://smartchaos.github.io/leetcode-shua-ti-ji-002/</id>
        <link href="https://smartchaos.github.io/leetcode-shua-ti-ji-002/">
        </link>
        <updated>2019-03-05T05:08:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="问题">问题</h2>
<p><a href="https://leetcode.com/problems/add-two-numbers/">两个链表相加问题，情境类似于十进制大数加法</a></p>
<h2 id="解决方案">解决方案</h2>
<h3 id="原始方案">原始方案</h3>
<p>问题难点在于边界，直接上代码</p>
<pre><code class="language-java">public ListNode addTwoNumbers(ListNode l1, ListNode l2) {int carryFlag = 0, plusHolder;
        ListNode res = null;
        ListNode curPos = null;
        while (true) {
            plusHolder = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + carryFlag;
            carryFlag = plusHolder / 10;
            ListNode newNode = new ListNode(carryFlag == 0 ? plusHolder : (plusHolder - 10));
            if (res == null) {
                res = newNode;
                curPos = res;
            } else {
                curPos.next = newNode;
                curPos = curPos.next;
            }
            if (l1 != null)
                l1 = l1.next;
            if (l2 != null)
                l2 = l2.next;
            if (l1 == null &amp;&amp; l2 == null &amp;&amp; carryFlag != 1) {
                return res;
            }
        }
    }
</code></pre>
<p>执行结果如下：</p>
<blockquote>
<p>Runtime: 19 ms, faster than 99.90% of Java online submissions for Add Two Numbers.<br>
Memory Usage: 48.2 MB, less than 17.15% of Java online submissions for Add Two Numbers.</p>
</blockquote>
<p>从结果来看广大网友似乎更多是在节省空间复杂度上下了功夫。</p>
<h3 id="改进思路">改进思路，</h3>
<p>是不是可以利用L1或者L2保存结果以节省空间呢？也就是以常见的merge链表的思路去做</p>
<pre><code class="language-java">public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        int carryFlag = 0, plusHolder;
        ListNode prevPos = l1;
        ListNode headPos = l1;
        while (true) {
            plusHolder = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + carryFlag;
            carryFlag = plusHolder / 10;
            if (l1 == null) {
                ListNode newNode = new ListNode(carryFlag == 0 ? plusHolder : (plusHolder - 10));
                prevPos.next = newNode;
                l1 = prevPos.next;
            } else {
                l1.val = carryFlag == 0 ? plusHolder : (plusHolder - 10);
            }
            prevPos = l1;
            l1 = l1.next;
            if (l2 != null)
                l2 = l2.next;
            if (l1 == null &amp;&amp; l2 == null &amp;&amp; carryFlag != 1) {
                return headPos;
            }
        }
    }
</code></pre>
<p>结果在执行\空间占用上面确有优化：</p>
<blockquote>
<p>Runtime: 19 ms, faster than 99.90% of Java online submissions for Add Two Numbers.<br>
Memory Usage: 47.8 MB, less than 41.60% of Java online submissions for Add Two Numbers.</p>
</blockquote>
]]></content>
    </entry>
</feed>